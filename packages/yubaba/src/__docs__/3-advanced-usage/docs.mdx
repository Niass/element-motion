---
name: 3. Advanced usage üèÉ
route: /advanced-usage
order: 3
---

import { Playground } from 'docz';
import * as Common from 'yubaba-common';
import MenuIcon from '@material-ui/icons/Menu';
import SearchIcon from '@material-ui/icons/Search';
import MoreVert from '@material-ui/icons/MoreVert';
import ImageIcon from '@material-ui/icons/Image';
import StarIcon from '@material-ui/icons/StarBorder';
import BackIcon from '@material-ui/icons/ArrowBack';
import { findDOMNode } from 'react-dom';
import { MemoryRouter, Switch, Route } from 'react-router-dom';
import {
  AppBar,
  Toolbar,
  IconButton,
  Typography,
  List,
  Avatar,
  ListItem,
  ListItemText,
  Divider,
} from '@material-ui/core';
import * as Styled from './styled';
import { WrappedAnimator as Animator } from '../../Animator';
import { WrappedVisibilityManager as VisibilityManager } from '../../VisibilityManager';
import CircleExpand from '../../animations/CircleExpand';
import TripeHoverMenu from '../../animations/ReshapingContainer/__docz__/TripeHoverMenu';
import FocalRevealMove from '../../animations/FocalRevealMove';
import FocalConcealMove from '../../animations/FocalConcealMove';
import FocalTarget from '../../FocalTarget';
import Move from '../../animations/Move';
import CircleShrink from '../../animations/CircleShrink';
import ovi from './images/ovechkin.jpg';
import EmailChain from './EmailChain';
import PopmotionMoveRight from './PopmotionMoveRight';

# Advanced usage

## Use with other libaries

Doing everything is a pretty hard gig.
Luckily `yubaba` works great with other libraries!

### [React Transition Group](https://reactcommunity.org/react-transition-group)

Useful when you have an animation you want to happen when an element is entering or leaving,
for example here in our _tripe.com_ menu we use it for just that!

<Playground>
  <TripeHoverMenu />
</Playground>

```js
({ isMenuShown, shownMenuId }) => (
  <CSSTransition in={isMenuShown} unmountOnExit mountOnEnter timeout={{ enter: 0, exit: 100 }}>
    <div class="menu-container">
      <ReshapingContainer id="reshape-with-transition" triggerKey={shownMenuId}>
        hello world
      </ReshapingContainer>
    </div>
  </CSSTransition>
);
```

> **Tip -** This example is using the [ReshapingContainer](/reshaping-container) component.
> It will reshape the background around the children when its prop `triggerKey` changes!

### [Popmotion](https://popmotion.io/pure/)

Creating [custom animations](/custom-animations) with third party libraries works a treat,
remember that although `yubaba` comes with beautiful animations out of the box -
at its core is a powerful orchestration layer you can use to write your own!

Here we use Popmotion to do the animating.

<Playground>
  <Common.Toggler interval>
    {toggler => (
      <Animator name="popmotion-right" key={toggler.shown}>
        <PopmotionMoveRight>{anim => <Styled.Root {...anim} />}</PopmotionMoveRight>
      </Animator>
    )}
  </Common.Toggler>
</Playground>

> **Tip -** [React Spring](https://www.react-spring.io/) can also be used for similar results using its imperative [Manual API](https://www.react-spring.io/docs/props/gotchas#manual-api).

```js
import { Collector } from 'yubaba';
import React, { useRef } from 'react';
import { styler, tween } from 'popmotion';

const PopmotionMoveRight = props => {
  const elementStyler = useRef();

  return (
    <Collector
      data={{
        action: 'animation',
        payload: {
          beforeAnimate: (elements, onFinish, setChildProps) => {
            elementStyler.current = styler(elements.destination.element);
            onFinish();
          },
          animate: (elements, onFinish, setChildProps) => {
            tween({ from: 0, to: { x: 300 } }).start({
              complete: onFinish,
              update: elementStyler.current,
            });
          },
        },
      }}
    >
      {props.children}
    </Collector>
  );
};
```

## Controlling in what order animations should execute

> **Tip -** Animations have three phases,
> `beforeAnimate()`,
> `animate()` and `afterAnimate()`.
> Don't worry if you're confused we will go over them in detail in [Custom Animations](/custom-animations).

Animations are executed from top to bottom.
The parent-most animation will be executed first and then continue execution inwards.

So if we had two animations, Move and CrossFade:

```js
() => (
  <Animator name="move-first">
    <Move>
      <CrossFade>{props => <div {...props} />}</CrossFade>
    </Move>
  </Animator>
);
```

When executed the order would look like:

1. Move `beforeAnimate()` fired
1. CrossFade `beforeAnimate()` fired
1. Move `animate()` fired
1. CrossFade `animate()` fired
1. Move `afterAnimate()` fired
1. CrossFade `afterAnimate()` fired

<br />

If we placed CrossFade first:

```js
() => (
  <Animator name="cross-fade-first">
    <CrossFade>
      <Move>{props => <div {...props} />}</Move>
    </CrossFade>
  </Animator>
);
```

Then their order would be inversed:

1. CrossFade `beforeAnimate()` fired
1. Move `beforeAnimate()` fired
1. CrossFade `animate()` fired
1. Move `animate()` fired
1. CrossFade `afterAnimate()` fired
1. Move `afterAnimate()` fired

## Wait for the previous animation to finish before starting the next

Depending on the animations chosen you'll want to defer starting one until the previous has finished.
Luckily the [Wait](/wait) component has been made for that!

Continuing the example above,
if we introduce the Wait component:

```js
import { Wait } from 'yubaba';

() => (
  <Animator name="wait">
    <CrossFade>
      <Wait>
        <Move>{props => <div {...props} />}</Move>
      </Wait>
    </CrossFade>
  </Animator>
);
```

Then the Move animation will wait for the CrossFade animation to complete finish before starting,
the order then becoming:

1. CrossFade `beforeAnimate()` fired
1. CrossFade `animate()` fired
1. Move `beforeAnimate()` fired
1. Move `animate()` fired
1. CrossFade `afterAnimate()` fired
1. Move `afterAnimate()` fired

> **Tip -** Notice that afterAnimate's are always called the the same regardless of Wait usage.

## Delay showing content until all animations have finished

Occasionally when initiating an animation we can have some secondary content we want to keep hidden until the animation has finished.
Luckily [VisibilityManager](/visibility-manager) exists to do just that!
Make it a parent of any [Animator](/animator) and it will show its content only when the animation has finished.

```js
import { VisibilityManager } from 'yubaba';

() => (
  <VisibilityManager>
    {manager => (
      <div>
        <Animator name="hide-children-until-animations-have-finished">
          <CrossFade>
            <Move>{props => <div {...props} />}</Move>
          </CrossFade>
        </Animator>

        <span {...manager}>Children content</span>
      </div>
    )}
  </VisibilityManager>
);
```

Children content will be shown after **all** animations have completed.

> **Tip -** If you have multiple child [Animator](/animator) you can pass [VisibilityManager](/visibility-manager) a `name` prop to target a specific [Animator](/animator).

## Using supporting animations

While movement is a large part of `yubaba` we can do so much more!
When building a great user experience its also useful to have supporting animation to help seamlessly transition from one state to another.

Two extra tools we have to do this is [CircleExpand](/circle-expand) and [CircleShrink](/circle-shrink) animations,
used together can produce a really cool transition between states.

<Playground>
  <Styled.Center>
    <Common.SmallViewport>
      <Common.Toggler>
        {({ shown, toggle }) => (
          <div id="yo">
            {!shown ? (
              <Styled.Container>
                <Animator name="circle-expand-square" key="1">
                  <CircleExpand background="#fea3aa">
                    {({ ref, style }) => (
                      <Styled.Root onClick={() => toggle()} style={style} ref={ref} />
                    )}
                  </CircleExpand>
                </Animator>
              </Styled.Container>
            ) : (
              <VisibilityManager>
                {props => (
                  <Styled.Container
                    onClick={() => toggle()}
                    style={{ cursor: 'pointer', background: '#005aff', ...props.style }}
                  >
                    <Animator name="circle-expand-square" key="2">
                      <CircleShrink background="#005aff">
                        {({ ref, style }) => <div style={style} ref={ref} />}
                      </CircleShrink>
                    </Animator>
                  </Styled.Container>
                )}
              </VisibilityManager>
            )}
          </div>
        )}
      </Common.Toggler>
    </Common.SmallViewport>
  </Styled.Center>
</Playground>

> **Tip -** [VisibilityManager](/visibility-manager) has been used as well to hide the next contents until the animation has finished,
> resulting in that crisp transition.

## Moving using a focal target

At times we want to move all content at once but have it originate from a focal point.
The [FocalTarget](/focal-target) component exists to mark the focal element so animations who care can use it.
Two examples of animations who can use it are [Move](/move), [FocalConcealMove](/focal-conceal-move).

<Playground>
  <Styled.Center>
    <EmailChain />
  </Styled.Center>
</Playground>

> **Tip -** Have a cool idea for an animation but you haven't seen any available yet?
> Check out [Custom animations](/custom-animations) to see how you can build your own!
